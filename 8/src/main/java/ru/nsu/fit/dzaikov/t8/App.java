/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.dzaikov.t8;

import sun.misc.Signal;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.AtomicBoolean;

public class App {
  private static final int N = 10000;

  public static void main(String[] args) {

    AtomicBoolean stopFlag = new AtomicBoolean(false);

    Signal.handle(new Signal("INT"), signal -> {
      System.out.println("stopping");
      stopFlag.set(true);
    });


    final int threadsCnt = Integer.parseInt(args[0]);
    final CyclicBarrier barrier = new CyclicBarrier(threadsCnt + 1);
    Thread[] threads = new Thread[threadsCnt];
    PiCalculator[] piCalculators = new PiCalculator[threadsCnt];

    for (int i = 0; i < threadsCnt; i++) {
      final int I = i;
      piCalculators[i] = new PiCalculator(barrier, i * N / threadsCnt, (i + 1) * N / threadsCnt, N);
      threads[i] = new Thread(piCalculators[i]);
      threads[i].start();
    }
    new Thread(()->{
      try {
        Thread.sleep(9000);
      } catch (InterruptedException ignored) {

      }
      Signal.raise(new Signal("INT"));
    }).start();
    while (!stopFlag.get()) {
      if (stopFlag.get()){
        for (int i = 0; i < threadsCnt; i++) {
          piCalculators[i].setStopFlag();
        }
      }
      try {
        barrier.await();
      } catch (InterruptedException | BrokenBarrierException ignored) {

      }
    }
    double res = 0;
    for (int i = 0; i < threadsCnt; i++) {
      res += piCalculators[i].getSum();
    }
    res *= 4;
    System.out.println(res);
    System.exit(0);
  }
}
